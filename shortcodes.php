<?php
/**
 * Shortcodes for SyntaxHighlighter Amplified
 *
 * @package SyntaxHighlighterAmplified
 *
 */

namespace SyntaxHighlighterAmplified;


// Display hooks
add_filter( 'the_content', __NAMESPACE__ . '\priority_shortcode', 7 ); // Posts
add_filter( 'comment_text', __NAMESPACE__ . '\priority_shortcode', 7 ); // Comments
add_filter( 'bp_get_the_topic_post_content', __NAMESPACE__ . '\priority_shortcode', 7 ); // BuddyPress

// Widget hooks
add_filter( 'widget_text', __NAMESPACE__ . '\priority_shortcode', 7 );

// Remove some shortcodes we don't want while still supporting them as language values
function listSupportedShortcodes() {
	global $languages;
	$shortcodes = array_keys($languages);
	unset( $shortcodes[array_search( 'latex', $shortcodes )] ); // Remove "latex" shortcode (it'll collide)
	unset( $shortcodes[array_search( 'r', $shortcodes )] ); // Remove "r" shortcode (too short)
	return $shortcodes;
}

// Plugin options used for shortcode default values
$options = get_option( 'shamp_plugin_options' );

// Create a list of shortcodes to use.
// If the language/lang parameter is left out, it's assumed the shortcode name is the language.
// If that's invalid, then "plaintext" is used.
$shortcodes = array( 'sourcecode', 'source', 'code' );
$shortcodes = array_merge( $shortcodes, listSupportedShortcodes() );

// Register each shortcode with a placeholder callback that will do nothing but will allow the shortcode to be stripped
// The proper callback and actual processing of the shortcode happens in priority_shortcode()
foreach ( $shortcodes as $shortcode )
	add_shortcode( $shortcode, '__return_false' );

/**
 * Process only this plugin's shortcodes.
 *
 * If we waited for the normal do_shortcode() call at priority 11,
 * then wpautop() and maybe others would mangle all of the code.
 *
 * So instead we hook in earlier with this function and process
 * just this plugins's shortcodes.
 *
 * First we need to clear out all existing shortcodes, then register
 * just this plugin's ones, process them, and then restore the original
 * list of shortcodes.
 *
 * To make matters more complicated, if someone has done [[code]foo[/code]]
 * in order to display the shortcode (not render it), then do_shortcode()
 * will strip the outside brackets and when do_shortcode() runs a second
 * time later on, it will render it.
 *
 * So instead before do_shortcode() runs for the first time, we add
 * even more brackets escaped shortcodes in order to result in
 * the shortcodes actually being displayed instead rendered.
 *
 * @param string $content     The post content.
 *
 * @return string The filtered content, with this plugin's shortcodes parsed.
 */
function priority_shortcode( $content ) {
	global $shortcode_tags;
	global $shortcodes;

	// Check if one of our shortcodes is present
	if ( ! has_shortcodes( $content ) ) {
		return $content;
	}
		
	// Backup current registered shortcodes and clear them all out
	$orig_shortcode_tags = $shortcode_tags;
	remove_all_shortcodes();

	// Register all of this plugin's shortcodes
	foreach ( $shortcodes as $shortcode ) {
		add_shortcode( $shortcode, __NAMESPACE__ . '\shortcode_callback' );
	}

	$regex = '/' . get_shortcode_regex( $shortcodes ) . '/';

	// Parse the shortcodes (only this plugins's are registered)
	// Extra escape escaped shortcodes because do_shortcode_tag() called by do_shortcode() is going to strip a pair of square brackets when it runs
	$content = preg_replace_callback(
		$regex,
		__NAMESPACE__ . '\add_extra_escape_to_escaped_shortcodes',
		$content
	);

	// Normal, safe parsing
	$content = do_shortcode( $content, true );

	// Put the original shortcodes back
	$shortcode_tags = $orig_shortcode_tags;

	return $content;
}

/**
 * A quick checker to see if any of this plugin's shortcodes are in use in a string.
 * Since all of the tags can't be self-closing, we look for the closing tag.
 *
 * @param string $content     The content to look through.
 *
 * @return bool Whether any shortcode usage was found.
 */
function has_shortcodes( $content ) {
	global $shortcodes;
	foreach ( $shortcodes as $shortcode ) {
		if ( false !== strpos( $content, "[/{$shortcode}]" ) ) {
			return true;
		}
	}
	
	return false;
}

/**
 * Add extra square brackets around escaped shortcodes.
 * This is to counteract the beginning of the do_shortcode_tag() function.
 *
 * @param array $match The array of matches generated by get_shortcode_regex()
 *
 * @return string What should be placed into the post content. In this case it's the raw match, or an extra-wrapped raw match.
 */
function add_extra_escape_to_escaped_shortcodes( $match ) {
	if ( $match[1] == '[' && $match[6] == ']' ) {
		return '[' . $match[0] . ']';
	}

	return $match[0];
}

// Shortcode handler for transforming the shortcodes to their final <pre>'s
function shortcode_callback( $atts, $code = '', $tag = false ) {
	global $post;
	global $shortcodes;

	if ( false === $tag || empty( $code ) ) {
		return $code;
	}

	// Avoid PHP notices
	if ( ! isset( $post ) ) {
		$post = null;
	}

	// Error fixing for [tag="language"]
	if ( isset( $atts[0] ) ) {
		$atts = attributefix( $atts );
		$atts['language'] = $atts[0];
		unset( $atts[0] );
	}

	// Default out all of the available attributes to false.
	// That is an easy way to filter out non valid shortcode attributes.
	// This isn't the same as if the user passes the string "false" since we check each value using type match.
	$atts = shortcode_atts( array(
		'language'       => false,
		'lang'           => false,
		'autolinks'      => false,
		'classname'      => false,
		'firstline'      => false,
		'gutter'         => false,
		'highlight'      => false,
		'altlines'       => false,
		'light'          => false,
		'padlinenumbers' => false,
		'smarttabs'      => false,
		'tabsize'        => false,
		'wraplines'      => false,
		'title'          => false,
	), $atts );
	
	// Check for language shortcode tag such as [php]code[/php]
	if ( in_array( $tag, $shortcodes ) ) {
		$lang = $tag;
	}

	// If a valid tag is not used, it must be sourcecode/source/code
	else {
		$atts = attributefix( $atts );

		// Check for the "language" attribute
		if ( false !== $atts['language'] )
			$lang = $atts['language'];

		// Check for the "lang" attribute
		elseif ( false !== $atts['lang'] )
			$lang = $atts['lang'];

		// Default to plain text
		else
			$lang = 'plaintext';

		// All language aliases are lowercase
		$lang = strtolower( $lang );

		// Validate passed shortcode tag
		if ( ! in_array( $tag, $shortcodes ) ) {
			return $code;
		}
	}
	
	$params = array();
	$params[] = "brush: $lang;";

	// Allowed configuration parameters and their type
	// Use the proper names (see above)
	$allowed_atts = array(
		'autolinks'       => 'boolean',
		'classname'       => 'other',
		'firstline'       => 'integer',
		'gutter'          => 'boolean',
		'highlight'       => 'other',
		'altlines'        => 'boolean',
		'light'           => 'boolean',
		'padlinenumbers'  => 'other',
		'smarttabs'       => 'boolean',
		'tabsize'         => 'integer',
		'wraplines'       => 'boolean',
		'title'           => 'other',
	);

	$title = '';

	// Sanitize configuration parameters and such
	foreach ( $atts as $key => $value ) {
		$key = strtolower( $key );

		// Skip this parameter if it's not set, or the language which was already handled
		if ( false === $value || in_array( $key, array( 'language', 'lang' ) ) ) {
			continue;
		}

		// Sanitize values
		switch ( $allowed_atts[ $key ] ) {
			case 'boolean':
				$value = strtolower( $value );
				if ( 'true' === $value || '1' === $value )
					$value = 'true';
				elseif ( 'false' === $value || '0' === $value )
					$value = 'false';
				else
					continue 2; // Invalid value, ditch parameter
				break;

				// integer
			case 'integer':
				$value = (int) $value;
				break;
		}

		// Sanitize the "classname" parameter
		if ( 'classname' == $key )
			$value = "'" . trim( preg_replace( '/[^a-zA-Z0-9 _-]/i', '', $value ) ) . "'";

		// Sanitize row highlights
		if ( 'highlight' == $key ) {
			if ( false === strpos( $value, ',' ) && false === strpos( $value, '-' ) ) {
				$value = (int) $value;
			} else {
				$lines = explode( ',', $value );
				$highlights = array();

				foreach ( $lines as $line ) {
					// Line range
					if ( false !== strpos( $line, '-' ) ) {
						list( $range_start, $range_end ) = array_map( 'intval', explode( '-', $line ) );
						if ( ! $range_start || ! $range_end || $range_end <= $range_start )
							continue;

						for ( $i = $range_start; $i <= $range_end; $i++ )
							$highlights[] = $i;
					} else {
						$highlights[] = (int) $line;
					}
				}

				natsort( $highlights );

				$value = implode( ',', $highlights );
			}

			if ( empty( $value ) )
				continue;

			// Wrap highlight in [ ]
			$params[] = "$key: [$value];";
			continue;
		}
		
		// Special sanitization for "padlinenumbers"
		if ( 'padlinenumbers' == $key ) {
			$value = strtolower( $value );
			if ( 'true' === $value || '1' === $value )
				$value = 'true';
			elseif ( 'false' === $value || '0' === $value )
				$value = 'false';
			else
				$value = (int) $value;
		}

		// Don't allow HTML in the title parameter
		if ( 'title' == $key ) {
			$value = strip_tags( html_entity_decode( strip_tags( $value ) ) );
		}

		$params[] = "$key: $value;";

		// Set the title variable if the title parameter is set (but not for feeds)
		if ( 'title' == $key && ! is_feed() )
			$title = ' title="' . esc_attr( $value ) . '"';
	}
	
	$code = ( false === strpos( $code, '<' ) && false === strpos( $code, '>' ) ) ? strip_tags( $code ) : htmlspecialchars( $code );

	// Escape shortcodes
	$code = preg_replace( '/\[/', '&#91;', $code );

	$params[] = 'notranslate'; // For Google, see http://otto42.com/9k

	return '<pre class="' . esc_attr( implode( ' ', $params ) ) . '"' . $title . '>' . $code . '</pre>';
}

// No-name attribute fixing
function attributefix( $atts = array() ) {
	if ( empty( $atts[0] ) ) {
		return $atts;
	}

	if ( 0 !== preg_match( '#=("|\')(.*?)\1#', $atts[0], $match ) ) {
		// Quoted value
		$atts[0] = $match[2];

	} elseif ( '=' == substr( $atts[0], 0, 1 ) ) {
		// Unquoted value
		$atts[0] = substr( $atts[0], 1 );
	}

	return $atts;
}